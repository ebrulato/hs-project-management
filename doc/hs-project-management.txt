-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/ebrulato/hs-project-management#readme</a>
@package hs-project-management
@version 0.1.0.0


-- | Contains the definitions of the common types used in our current
--   project.
module Aggregate.PM.Types

-- | Price allowes to describe the cost of a ressource.
type Price = Int

-- | The types of Aggregates used in our project
data AggregateType

-- | Users are external aggregates provided by an other micro-service.
ExternalUser :: AggregateType

-- | Project are managed by our micro-service
Project :: AggregateType

-- | Used to describe the work of an ExternalUser on the Project or other
--   cases...
Imputation :: AggregateType
instance GHC.Classes.Eq Aggregate.PM.Types.AggregateType
instance GHC.Generics.Generic Aggregate.PM.Types.AggregateType
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Types.AggregateType
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Types.AggregateType


-- | Extenal Users are defined in an other micro-service. These information
--   came from an other system
module Aggregate.PM.User

-- | A User Aggregate is very simple
data User

-- | As User are external component, we use only a String version of its
--   original key
type UserId = String

module DomainEvent.Event
data Event
Event :: UUID -> AggregateType -> UTCTime -> Int -> Value -> Event
[_id] :: Event -> UUID
[_aggregate] :: Event -> AggregateType
[_time] :: Event -> UTCTime
[_sequence] :: Event -> Int
[_payload] :: Event -> Value
genEvent :: UUID -> AggregateType -> UTCTime -> Int -> Value -> Event
checkSequence :: [Event] -> Either () [Event]
instance GHC.Classes.Eq DomainEvent.Event.Event
instance GHC.Generics.Generic DomainEvent.Event.Event
instance Data.Aeson.Types.ToJSON.ToJSON DomainEvent.Event.Event
instance Data.Aeson.Types.FromJSON.FromJSON DomainEvent.Event.Event
instance GHC.Classes.Ord DomainEvent.Event.Event


-- | A maybe reusable definition of what is an <tt>Aggregate</tt>...
module Aggregate.Aggregate

-- | Definition of the Aggregate behaviors
class Aggregate a

-- | the id of and Aggregate
aggregateId :: Aggregate a => a -> UUID

-- | an aggregate has a version based on its last update.
version :: Aggregate a => a -> Version

-- | a way to source the aggregate from a list of events
source :: Aggregate a => Maybe a -> [Event] -> Either String a

-- | A Version as a simple integer
type Version = Int


-- | One of the most important Aggregate of this application. It manages
--   the main project description, with its backlog, its team and its
--   planned workload.
module Aggregate.PM.Project

-- | A project is the aggragation of...
data Project
type ProjectId = UUID
data ProjectMode
Scrum :: Int -> ProjectMode
Kanban :: ProjectMode
genProjectId :: IO UUID

-- | Used to create a Project
createProject :: ProjectId -> String -> Text -> Day -> ProjectMode -> UTCTime -> (Event, Project)

-- | Update the Name
updateName :: Project -> Text -> UTCTime -> (Event, Project)
instance GHC.Generics.Generic Aggregate.PM.Project.UpdateProject
instance GHC.Show.Show Aggregate.PM.Project.UpdateProject
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Project.UpdateProject
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Project.UpdateProject
instance Aggregate.Aggregate.Aggregate Aggregate.PM.Project.Project
instance GHC.Classes.Eq Aggregate.PM.Project.Project
instance GHC.Generics.Generic Aggregate.PM.Project.Project
instance GHC.Show.Show Aggregate.PM.Project.Project
instance GHC.Classes.Eq Aggregate.PM.Project.Role
instance GHC.Generics.Generic Aggregate.PM.Project.Role
instance GHC.Show.Show Aggregate.PM.Project.Role
instance GHC.Show.Show Aggregate.PM.Project.ProjectState
instance GHC.Classes.Eq Aggregate.PM.Project.UserStory
instance GHC.Generics.Generic Aggregate.PM.Project.UserStory
instance GHC.Show.Show Aggregate.PM.Project.UserStory
instance GHC.Classes.Eq Aggregate.PM.Project.UserStoryState
instance GHC.Generics.Generic Aggregate.PM.Project.UserStoryState
instance GHC.Show.Show Aggregate.PM.Project.UserStoryState
instance GHC.Classes.Eq Aggregate.PM.Project.ProjectMode
instance GHC.Generics.Generic Aggregate.PM.Project.ProjectMode
instance GHC.Show.Show Aggregate.PM.Project.ProjectMode
instance GHC.Classes.Eq Aggregate.PM.Project.Complexity
instance GHC.Generics.Generic Aggregate.PM.Project.Complexity
instance GHC.Show.Show Aggregate.PM.Project.Complexity
instance GHC.Classes.Eq Aggregate.PM.Project.BusinessValue
instance GHC.Generics.Generic Aggregate.PM.Project.BusinessValue
instance GHC.Show.Show Aggregate.PM.Project.BusinessValue
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Project.Project
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Project.Project
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Project.Role
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Project.Role
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Project.UserStory
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Project.UserStory
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Project.UserStoryState
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Project.UserStoryState
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Project.ProjectMode
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Project.ProjectMode
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Project.Complexity
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Project.Complexity
instance Data.Aeson.Types.ToJSON.ToJSON Aggregate.PM.Project.BusinessValue
instance Data.Aeson.Types.FromJSON.FromJSON Aggregate.PM.Project.BusinessValue

module EventDB.EventDB
class EventDB a
add :: EventDB a => a -> [Event] -> UUID -> IO (Either String ())
events :: EventDB a => a -> UUID -> IO [Event]
partialEvents :: EventDB a => a -> UUID -> Version -> IO [Event]

module EventDB.Memory.EventDBMemory
data EventDBMemo
new :: IO EventDBMemo
instance GHC.Show.Show EventDB.Memory.EventDBMemory.EventDBMemo
instance EventDB.EventDB.EventDB EventDB.Memory.EventDBMemory.EventDBMemo

module Repository.Repository
data RepositoryError
NO_DATA :: RepositoryError
SEQUENCE_ERROR :: String -> RepositoryError
VERSION_ERROR :: RepositoryError
DATA_TYPE_ERROR :: RepositoryError
class Repository a
fetchProject :: Repository a => a -> ProjectId -> Version -> IO (Either RepositoryError Project)
instance GHC.Classes.Eq Repository.Repository.RepositoryError

module Repository.Memory.RepositoryMemory
data (EventDB a) => RepoMemo a
new :: EventDB a => a -> IO (RepoMemo a)
instance (EventDB.EventDB.EventDB a, GHC.Show.Show a) => GHC.Show.Show (Repository.Memory.RepositoryMemory.RepoMemo a)
instance EventDB.EventDB.EventDB a => Repository.Repository.Repository (Repository.Memory.RepositoryMemory.RepoMemo a)


-- | A maybe reusable definition of what is a <tt>Command Handler</tt>...
module Command.Command

-- | A command error... we have to work the definition of the error code.
data CommandError

-- | A Command is ...
class Command cmd

-- | can be used to perform simple check on the command values (eg. empty
--   string, ...)
doFilter :: Command cmd => cmd -> Maybe CommandError

-- | execute the command
execute :: (Command cmd, Repository repo) => cmd -> repo -> UTCTime -> IO (Either CommandError ([Event], Version, UUID))

module Command.PM.UpdateName
data CommandProjectUpdateName
CommandProjectUpdateName :: ProjectId -> Version -> Text -> CommandProjectUpdateName
[projectId] :: CommandProjectUpdateName -> ProjectId
[num] :: CommandProjectUpdateName -> Version
[newName] :: CommandProjectUpdateName -> Text
instance Command.Command.Command Command.PM.UpdateName.CommandProjectUpdateName

module Command.PM.Create
data CommandProjectCreation
CommandProjectCreation :: String -> Text -> Day -> ProjectMode -> CommandProjectCreation
[code] :: CommandProjectCreation -> String
[name] :: CommandProjectCreation -> Text
[start] :: CommandProjectCreation -> Day
[mode] :: CommandProjectCreation -> ProjectMode
instance Command.Command.Command Command.PM.Create.CommandProjectCreation


-- | A maybe reusable definition of what is a <tt>Bus</tt>...
module Bus.Bus

-- | This function is used to manage a Command in the bus. TODO 1 =&gt;
--   check the behavior if many command are performed at the same time...
--   if we use in memory or if we use a resilient implement of EventDB . *
--   TOOD 2 =&gt; maybe we could implement a list of command on the same
--   aggregate in the in the future...
perform :: (Command cmd, EventDB edb, Repository repo) => cmd -> edb -> repo -> IO (Either CommandError Version)
